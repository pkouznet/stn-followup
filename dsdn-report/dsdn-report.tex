\documentclass[11pt,pdftex,letter]{article}
%\documentclass[11pt]{llncs}
%\documentclass[11pt,pdftex]{article}
%\documentclass{sig-alternate-10pt}
%\usepackage{amsthm}
%\usepackage{algorithm}
%\usepackage[noend]{algorithmic}
\usepackage[lined,boxed,commentsnumbered]{algorithm2e}


\usepackage{amssymb}
\usepackage{comment}
\usepackage{amsmath}
%\usepackage{graphicx}
%\usepackage{color}
\usepackage{fullpage}
%\usepackage[pdftex]{graphicx}
%\DeclareGraphicsRule{*}{mps}{*}{<++>}

\ifx\pdftexversion\undefined
\usepackage[dvips]{graphicx}
\else
  \usepackage[pdftex]{graphicx}
  \DeclareGraphicsRule{*}{mps}{*}{}
\fi


\def\lf{\tiny}
\def\rrnnll{\setcounter{linenumber}{0}}
\def\nnll{\refstepcounter{linenumber}\lf\thelinenumber}
\newcounter{linenumber}

\usepackage[usenames,dvipsnames]{color}
%\usepackage[caption=true,font=footnotesize]{subfig}
\usepackage{subfigure}
%\usepackage{xspace} 	% Guesses whether a space is needed when invoked
\usepackage{listings}
\usepackage{url}
\usepackage{wrapfig}
\usepackage{cite}
%\usepackage{framed}
\usepackage{framed,color}
\definecolor{shadecolor}{rgb}{0.9,0.9,0.9}
%
\usepackage[boxed]{algorithm2e}
%\usepackage{comment}

%[[PKto change spacing
%\usepackage{titlesec}
%\titlespacing\section{0pt}{7pt}{6pt}
%]]

%\newtheorem{theorem}{Theorem}[section]
%\newtheorem{takeaway}[theorem]{Takeaway}
%\newtheorem{fact}[theorem]{Fact}


%\pdfpagewidth=8.5in
%\pdfpageheight=11in

% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/misc/
% Read the url.sty source comments for usage information. Basically,
% \url{my_url_here}.

\newcommand{\CPO}{\textsc{FixTag}}
\newcommand{\DPO}{\textsc{ReuseTag}}
\newcommand{\PS}{\textsc{PS}}
\newcommand{\Bit}{\textsc{Bit}}

\newcommand{\gns}{Global Network State\xspace}
\newcommand{\GNS}{\textsc{GNS}\xspace}

%\newtheorem{theorem}{Theorem}[section]
%\newtheorem{lemma}{Lemma}[section]
%\newtheorem{claim}{Claim}[section]
%\newtheorem{scenarios}{Scenarios}[section]
%\newtheorem{observation}{Observation}
%\newtheorem{takeaway}{Takeaway}[section]
%\newtheorem{definition}{Definition}


%
%
% carry over Herald's group cool way of marking changes
\definecolor{heraldBlue}{rgb}{0.0,0.0,0.8}
\definecolor{heraldRed}{rgb}{0.8,0.0,0.0}
\definecolor{heraldGray}{rgb}{0.4,0.4,0.4}
\definecolor{heraldBlack}{rgb}{0.0,0.0,0.0} %removes comment color
\definecolor{heraldGreen}{rgb}{0.0,0.4,0.0} %removes comment color
\def\r#1{\textcolor{heraldBlue}{\em #1}}
\def\q#1{\textcolor{heraldRed}{\em #1}}
\def\d#1{\textcolor{heraldBlue}{#1}}
\def\R#1{\textcolor{heraldBlue}{#1}}
\def\D#1{\textcolor{heraldBlue}{#1}}
%
%\DeclareMathOperator{\respc}{res}

\newcommand{\len}{\text{d}}

\newcommand{\nodes}{\mathcal{N}}
\newcommand{\links}{\mathcal{E}}
\newcommand{\epoints}{\Pi}
\newcommand{\epoint}{\pi}
\newcommand{\legsw}{\mathcal{L}}
\newcommand{\sdnsw}{\mathcal{S}}
\newcommand{\sw}{\legsw\sqcup\sdnsw}
\newcommand{\fset}{FS}

\newcommand{\Cost}{\gamma}

\newcommand{\ft}{ft}

\newcommand{\eepath}{p}
\newcommand{\link}{e}

\newcommand{\dom}{\textit{dom}}
\newcommand{\pr}{\textit{pr}}
\newcommand{\CPOs}{\textit{paths}}
\newcommand{\seq}{\textit{seq}}
\newcommand{\cur}{\textit{cur}}
\newcommand{\Tag}{\textit{tag}}


\newcommand{\ports}{\Pi}
\newcommand{\seport}{\pi}
\newcommand{\inports}{\overrightarrow{\ports}}
\newcommand{\swports}{\overleftrightarrow{\ports}}
\newcommand{\seinports}{\epoints^{\bullet}}
\newcommand{\seinportsone}{\seinports_1}
\newcommand{\seinportstwo}{\seinports_2}
\newcommand{\seinportsthree}{\seinports_3}
\newcommand{\neinports}{\epoints^{\circ}}

\newcommand{\readt}{\texttt{r}}
\newcommand{\writet}{\texttt{w}}
\newcommand{\op}{\texttt{op}}


\newcommand{\cellblocks}{CB}
\newcommand{\cellblock}{c}
\newcommand{\frontier}{\mathcal{F}}
\newcommand{\MIP}{\textsc{Opt}}
\newcommand{\smartparagraph}[1]{\noindent{\bf #1}\ }
\newcommand{\eg}{{\it e.g.}}
\newcommand{\ie}{{\it i.e.}}
\newcommand{\etc}{{\it etc.}}
\newcommand{\etal}{{\it et al.}\xspace}
\newcommand{\id}{{\it id}}

\def\TR{0}
\def\NOTES{1}
\def\SAVESPACE{1}
\def\SHOWAUTHORS{1}
\def\SHOWGIT{0}
% variables may contain the above definitions to control build options at compile-time
%\input{variables}

\if \SAVESPACE 1
%\usepackage{setspace}
%\usepackage{titlesec}
%\titlespacing\section{0pt}{7pt}{6pt}
\usepackage{titlesec}
\titlespacing\section{0pt}{7pt}{6pt}

\fi

\if \NOTES 1
\newcommand{\mcnote}[1]{\textcolor{heraldBlue}{\small \bf [MC: #1]}}
\newcommand{\dlnote}[1]{\textcolor{heraldBlue}{\small \bf [DL: #1]}}
\newcommand{\ssnote}[1]{\textcolor{heraldBlue}{\small \bf [SS: #1]}}
\newcommand{\pknote}[1]{\textcolor{heraldBlue}{\small \bf [PK: #1]}}
%\newcommand{\problem}[1]{\textcolor{heraldRed}{\small \bf [PROBLEM: #1]}}
\else
\newcommand{\mcnote}[1]{}
\newcommand{\dlnote}[1]{}
\newcommand{\ssnote}[1]{}
\newcommand{\pknote}[1]{}
\newcommand{\problem}[1]{}
\fi

%Petr's definitions
\newcommand{\ack}{\textit{ack}}
\newcommand{\nack}{\textit{nack}}
\newcommand{\rmw}{\textit{rmw}}
\newcommand{\State}{\mathit{States}}
\newcommand{\ignore}[1]{}
\newcommand{\Pb}{CPC}
\newcommand{\E}{\mathcal E}
%

%[[PK environments for article style
\newtheorem{theorem}{Theorem}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{observation}[theorem]{Observation}
\newenvironment{proof}[1][Proof]{\noindent\textbf{#1.} }{\hfill $\Box$\\[2mm]}
\newenvironment{proofsketch}[1][Proof sketch]{\noindent\textbf{#1.} }{\hfill $\Box$\\[2mm]}
%]]

\begin{document}
\sloppy

%\title{Distributed Network Programming}
%\title{The Distributed SDN Update Problem:\\Towards Software Transactional Networks}

%\title{On Consistent Updates in Software Defined Networks under Unreliable Control}
%\title{The Case for Reliable Software Transactional Networking}

%\title{A Distributed SDN Control Plane for Concurrent Policy Updates}

\title{Distributed Software-Defined Networking:\\ ACM PODC 2014 Workshop }



\author{
Petr Kuznetsov$^{1}$ \quad Stefan Schmid$^{2}$\\
\\
       $^{1}$ T\'el\'ecom ParisTech\\
%, 46 Rue Barrault, 75013 Paris, France\\
        petr.kuznetsov@telecom-paristech.fr\\
\\
        $^{2}$ TU Berlin \& T-Labs \\ %Ernst-Reuter Platz 7, 10587 Berlin, Germany\\
	    stefan.schmid@tu-berlin.de}
%	}

%\institute{}

\date{}


\maketitle


\thispagestyle{empty}

%\if \SAVESPACE 1
%\setlength{\floatsep}{3pt}
%\setlength{\textfloatsep}{3pt}
%\setlength{\dbltextfloatsep}{3pt}
%\setlength{\intextsep}{3pt}
%\setlength{\abovecaptionskip}{3pt}
%\fi

% A category with the (minimum) three required fields
%\category{C.2.1}{Network Architecture and Design}{Centralized Networks}
%\category{C.2.4}{Distributed Systems}{Network Operating Systems}
%\terms{Measurement, Performance}
%\keywords{}



\begin{abstract}
The first workshop on Distributed Software-Defined Networking took
place in Paris, France, on the 15th of July, just before
the 33rd ACM Symposium on Principles of Distributed Computing.
The workshop intended to be a forum to discuss new algorithmic and
distributed computing challenges offered by the emerging field of
Software Defined Networking (SDN).
For the workshop, we invited invited researchers in the fields of
distributed computing and networking in order to understand whether distributed implementations of the
SDN control plane give rise to new and interesting research questions,
in solving which  the expertise of the PODC community may be of use.
\end{abstract}


\section{SDN and PODC?}

Computer networking currently goes through a transition phase:
the paradigm of Software-Defined Networking (SDN)
is discussed intensively, both in the industry and in the academia. In
a nutshell, SDN out-sources the control over the network
to a logically centralized software, called the \emph{control plane}.
The ability of the control plane to ``program'' the network (the
\emph{data plane}) opens new interesting opportunities to network
operators and system designers.

 While the perspective of a centralized controller simplifies network management,
it comes with the usual drawbacks: single point of failure,
scalability bottleneck, overhead due to indirection, etc.
This raises the questions: What kind of a \emph{distributed} control
plane for SDN is needed?
And if so, does it bring new and interesting questions the ``PODC
community'' can address?

In order to discuss these questions, we organized the workshop on Distributed
Software-Defined Networks (DSDN). The workshop took
place in Paris on the sunny day of July 15th, just before
PODC, concurrently with four other PODC workshops, and gathered the
audience of about 20-40 people (which could be considered as success).

The program consisted of invited and peer-reviewed presentations from researchers working in applied networking,
systems, and theory of distributed computing.


\section{Program}

Below we give a short overview of the talks given in our
workshop. Abstracts and slides can be found at \url{http://www.podc.org/podc2014/dsdn14/}.

\subsection{Foundations of SDN}



In the opening keynote, Nate Foster (Cornell) gave an overview of
programming abstractions for SDN. The talk consisted of three parts.

...

one of the leading figures in formal methods for networks, and the man behind the pyretic / frenetic project.

talk title: sdn foundations

Ongoing Work
Proof-Carrying Code
• Tenants generate proofs of important
network properties
• Administrators verify proofs from untrusted
tenants using simple checkers
Probabilistic Programming
• Encode randomized routing schemes
• Establish fault/congestion bounds
Deeper Foundations
• Understand SDN in terms of classic concepts
like {safe, regular, atomic} registers
• Develop analogs of non-blocking algorithms

…due to the proliferation of devices, protocols, languages

emphasized a formal and rigorous / correctness approach:
Networks are critical for ensuring the security of many
systems… so it is important they function as expected

Programming languages and formal methods have a key role
to play in software-defined networks
• By carefully engineering the right programming abstractions,
effective reasoning about network behavior becomes possible
- Featherweight OpenFlow
- NetKAT
- Consistent updates

Reasoning techniques! Enabling use of reasoning
techniques typically
associated with the
programming languages and
verification communities

Machine Model [PLDI ‘13]
Language Model [POPL’12, NSDI ’13, POPL ’14]
Run-Time Model [SIGCOMM ’12, SYNT ‘13]

Distributed Programming: Even updating a single
switch is challenging:
• Flow tables are huge
• OpenFlow only
provides instructions
for adding and
removing single entries
•Must update tables
while they are live and
processing packets

42 pages...
...of informal prose
...and C struct definitions

Parameterized Weak Bisimulation
Invariants
• Safety: at all times, the rules installed on switches are a
subset of the controller function
• Liveness: the controller eventually processes all packets
diverted to it by switches
Theorem
!

OpenFlow is a machine language!
Network-Wide Programming
What features should an SDN language provide?

Network Updates: Challenges
•Network is a distributed system
•Can only update one rule at a time
Our Approach
•Provide programmers with constructs
for updating the entire network at once
•Engineer semantics to guarantee
“reasonable” behavior during transition
•Run-time system:
-Constructs update protocols
-Applies optimizations automatically




\subsection{Consistent Range Classification with OpenFlow}

Yehuda Afek (TAU) presented his recent work with Anat Bremler-Barr and
Liron Schiff~\cite{AfekBS14}.


Cross-Entrance Consistent Range Classifier with OpenFlow
...

In this paper we present a new Openflow based architecture to manage flows across a multi entrance SDN network
in a consistent way, thus improving in several aspects on previous works [4, 5]. Our contributions are in three levels.
At the first level we use OpenFlow features in a sophisticated way to implement a range classification scheme which
to the best of our knowledge is more space efficient (only 3 entries per range) than previous known classifiers. In the
second contribution we show how to update ranges across multiple switches in an atomic manner - allows to update
the set of ranges and their associated actions while packets are classified and the network is changing. Finally, using
the two schemes above, we present an architecture suitable for several applications such as load-balancing, and NFV,
to manage multi-entrance consistency - keeping Per Flow consistency even when the flow changes the entrance point
to our network.
Our scheme utilizes advanced OpenFlow features to efficiently implement a complex computation of a nonoverlapping
range classification scheme which requires only 3n+2w+1 table entries (a significant saving is observed
already with 4 ranges - see Figure 1(b)), where n is the number of ranges and w is the size of values (e.g. 32 for IPv4
addresses). The three key OpenFlow features (and limitations) that we use are: (i) a packet can be processed by several
forwarding tables using ’goto’ action command to decide on the next table. (ii) a packet can be extended with an auxiliary
field which may be altered (e.g., xored with a constant) and considered as the packet goes through subsequent
flow tables. (iii) Openflow lack of support for general computation on packet field values.
Three levels of atomicity are considered and supported by our scheme: (i) Per packet consistency - each packet is
handled according to correct configuration either before or after the update. (ii) Per flow Consistency - all packets of a
flow are handled according to the same configuration and new flows are handled according to the newest configuration.
(iii) Cross-entrance consistency - keeping Per Flow consistency even when the flow changes the entrance point to our
network.
Our ranges classification is based on PIDR, a non-OpenFlow system design by Panigrahy and Sharma [3] which
uses special hardware (e.g., ASIC or FPGA) and has no notion of atomicity. PIDR creates two patterns for each range
called the ELCP0 and ELCP1 of the range (see definition in [3]) and save them separately in two TCAMs associated
with range bounds. The two TCAMs are arranged in a very specific manner to support the scheme. In order to classify
a value, it should be queried against the two TCAMs, returning two matches that are associated with two possible
ranges. Then the value is checked whether it belongs to one of these two ranges

We have designed atomic implementation of basic operations in the 3 consistency models, the operations are merge,
split and range update. From these operations we are developing an efficient OpenFlow based load-balancer. We also
found methods by which our design is improved in the future with the introduction of the following new OpenFlow
models: DevoFlow [2], which allows us to save control plane traffic for Per-Flow consistency (a similar idea is suggested
in [4]), and the model RMT (recongurable match tables) [1], can be used to replace the Compare table with a
computation stage

\subsection{SDN-Based Private Interconnection}

Shlomi Dolev1 Shimrit Tzur-David

Cloud computing is one of the fastest growing opportunities for enterprises and service providers. Enterprises use the Infrastructureas-
a-Service (IaaS) model to build private and public clouds that reduce operating and capital expenses and increase the agility
and reliability of their critical information systems. In order to fulfil these needs, service providers build public clouds to offer
on-demand, secure, multi-tenant IT infrastructure to potential costumers that now can use cloud services using a public cloud
infrastructure.
The Open Networking Foundation (ONF) report on the infrastructure between datacenters [?] states that fast-changing
and demanding enterprise and carrier business requirements force changes in network architecture. However, these changes
were focused on datacenter server and storage virtualization, while the underpinning network architectures have stagnated with
respect to both scalability and manageability.
Due to the growth of businesses and the advent of Big Data, the private clouds are augmented with external resources known
as public clouds. The use of public cloud requires efficient and well performed connectivity between private and public clouds.
This resulting “hybrid” cloud should provide transfer and sharing of data. Furthermore, this transfer has to be private.
SDN enables more deterministic, more scalable, more manageable and as we present in this paper, also private virtual
networks between the local datacenters that reside in the private cloud, to the public resources in the public cloud. These virtual
networks are called the hybrid cloud.
In this work we present a private hybrid cloud in which all the information that pass across the cloud is information theoretic
secured. I.e., unless there is a coalition of several routers in the cloud, the information cannot be revealed. This is done by using
secret sharing scheme together with SDN to ensure privacy. Encryption with (n;k) secret sharing scheme (n  k) is done by
creating n shares from the data such that only by having at least k shares, the data can be decrypted. In the cloud notations,
assume that the data has to be sent from the private datacenter. The source in the private datacenter creates n shares from the
data and sends them to the destination at the public cloud through the hybrid cloud. The SDN controller manages the routes of
these shares such that no router sees k or more shares. This way, we ensure that only the destination at the public cloud that gets
all the shares, can decrypt the data, resulting in a private channel in the hybrid cloud. When n > k, we allow n..k shares to get
lost, due to congestion or even by malicious routers.
Our Contribution. The contributions of our paper are as follows; To the best of our knowledge, we are the first to use secret
sharing for a unicast communication over SDN architecture. We show that secret sharing can be very useful to achieve private
channel when two parties communicate over a multipath network. Whereas many papers have some contribution on the area
of public cloud security, i.e., securing data in the cloud, to the best of our knowledge, we are the first to target the problem
of theoretical secured channel to the public cloud. We show that even if there is a probability to the existence of coalition of
several routers in the hybrid cloud, we can still bound the probability for privacy violation.
2 Gaining


\subsection{Software Transactional Networking: A Robust and
  Distributed SDN Control Plane}

Marco Canini (UCL) presented the concept of software transactional
networking (STN), a control-plane abstraction used for consistent
composition of concurrent policies~\cite{stn,tr-stn}. The abstraction assumes a set of
control applications that concurrently apply modifications (or
updates) of the
\emph{network policy}, i.e., the set of rules that stipulate how the
traffic should be processed at the data plane.
Given that the policy updates coming from different control applications may
conflict with each other, the STN framework offers to the applications
a \emph{transactional} interface with \emph{all-or-nothing} semantics.
The appealing difference with classical transactional systems is that
here we have to make sure that some kinds of transactions, namely
\emph{data-plane traffic} traces have to be processed in a manner that
is transparent to network-configuration changes.
The talk hinted on the formal definition of the abstraction of consistent policy
composition (CPC), and sketched designs of its resilient implementations.

\subsection{Declarative, Distributed Configuration}

Can the challenges motivating the use of SDN be addressed using
existing hardware and protocols. Sanjai Narain (Applied Communication Sciences) summarized the
experience collected at his company in using the Assured and Dynamic
Configuration(ADC) system. In their approach, network functionality is
expressed as a set of constraints on configuration variables. SAT or
SMT solvers are used to convert these constraints into values of configuration variables.
Of course, in specific scenarios, proprietary solutions may be more
efficient and  easier to deploy than generic ones (e.g., based on the
SDN framework), and Sanjai's talk questioned the very
motivation behind migrating to SDN.

\subsection{Managing the Network with Merlin}

Merlin:
A Language for
Provisioning
Network Resources

How to Program The Network?
2
Existing SDN languages focus mostly
on packet forwarding
Ignore other vital network features like
bandwidth, packet processing, etc.
Network orchestration frameworks
expose extremely simple APIs (if at all)

Merlin Approach
3
Specify
Compile
Specify global network policy in a
high-level declarative language.
Map to a constraint problem.
Provision network, select paths,
and decide function placement.
Generate device-specific code and
configuration to enforce policy.



Robert Soule Managing the Network with Merlin
Abstract: This talk presents the Merlin network management framework. With Merlin, administrators express network policy using programs in a declarative language based on logical predicates and regular expressions. The Merlin compiler automatically partitions these programs into components that can be placed on a variety of devices.
It uses a constraint solver to allocate resources such as paths and bandwidth. To ease the administration of federated networks, Merlin provides mechanisms for delegating management of sub-policies to tenants, along with tools for verifying that delegated sub-policies do not violate global constraints. Overall, Merlin greatly simplifies the task of network administration.

\subsection{Managing Dynamic Networks: Distributed or Centralized
  Control}

In his somewhat provocative talk, Roger Wattenhofer (ETHZ) considers
the following question. If we take the extreme case of a network
managed (e.g., using the SDN approach) by a (fault-tolerant,
performant, etc.) central controller, would this imply
that distributed algorithms are no longer needed. The answer (not very
surprisingly) is no: we still have to deal with the problem of
dynamicity and failures on the data plane, as well as the fact that
the data plane is inherently geographically distributed and cannot be
manipulated in the atomic manner. In short, we still have to deal with
\emph{consistency} of network control, and here we can benefit from
distributed computing which is essentially all about consistency.
In his talk, Roger overviewed several natural network consistency
criteria (such as \emph{loop-freedom} or \emph{per-packet
  consistency}) and sketched several impossibility results and
complexity bounds of achieving these criteria in a few different
network models.


\section{Distributed SDN: New? Interesting?}

A recently published detailed survey on the
SDN-related research so far~\cite{sdn-survey}
claims that ``the myth that logical centralization implied
a physically centralized controller'' has been addressed and, as a
result, ``SDN ideas have matured and evolved from
an academic exercise to a commercial success''.

Given that dealing with networking and computing aspects in the
same SDN system appears to be novel~\cite{roger-hotnets,stn-tr,stn} and
the apparent indispensability of \emph{distributed} control in SDN,
one may expect that this emerging area would bring new and interesting theory.
However, among 407 articles cited in~\cite{sdn-survey}, we do not find
a single paper that appeared in a \emph{theoretical} distributed-computing venue
(such as PODC or DISC).
We think, based on our personal research experience, this is not
because SDN does not give rise new and interesting
research questions related to distributed computing.
Maybe it is just lack of curiosity or insights on recent
advances in networking?

The workshop shows that the situation is slowly changing: a few
research groups are looking at the distributed aspects of SDN now.
It seems, however, that progress here is still rather modest and
typically boils down to solving ``conventional'' algorithmic problems,
using SDN only as a motivating application. We believe nevertheless that
there are deeper distributed challenges coming directly from SDN.


\bibliographystyle{abbrv}
\bibliography{references}  % main.bib is the name of the Bibliography in this case

\end{document}
